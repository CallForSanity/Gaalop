<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
	<title>CLUCalc: CLUCalc - A Visual Calculator</title>
	<link href="doxygen.css" rel="stylesheet" type="text/css">
	<link href="favicon.ico" rel="SHORTCUT ICON">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1><a class="anchor" name="page_WorkWithMV">Working with Multivectors</a></h1><ul>
<li>
<a class="el" href="page_WorkWithMV.html#sec_CreateMV">Creating Multivectors</a> </li>
<li>
<a class="el" href="page_WorkWithMV.html#sec_CalcMV">Calculating with Multivectors</a> </li>
<li>
<a class="el" href="page_WorkWithMV.html#sec_VisMV">Visualizing Multivectors</a> </li>
<li>
<a class="el" href="page_WorkWithMV.html#sec_Plot">Plotting Vector Functions</a> </li>
</ul>
<p>
In this section I assume that you are familiar with the basics of Clifford (or geometric) algebra. CLUScript currently supports three Clifford algebras: the Euclidean 3-space and the corresponding projective and conformal spaces. You can work with multivectors from all three spaces concurrently in the same script. However, you cannot operate with multivectors of one space onto multivectors of a another space. Instead, you have to cast multivectors explicitly.<p>
<hr>
 <h2><a class="anchor" name="sec_CreateMV">
Creating Multivectors</a></h2>
Currently only functions to create grade 1 multivectors (i.e. vectors) in the different spaces exist. Higher grade objects have to be build up from vectors. The functions to create vectors are called <a class="el" href="group__grp__GAFunc.html#ga36">VecE3()</a>, <a class="el" href="group__grp__GAFunc.html#ga42">VecP3()</a>, <a class="el" href="group__grp__GAFunc.html#ga39">VecN3()</a> and (<b>new in version 2.0</b>) <a class="el" href="group__grp__GAFunc.html#ga32">VecC2()</a> for the different spaces, respectively.<p>
The <code>VecXX</code> functions expect either a single counter, a list of two or three scalars or a single multivector. If you pass a single counter the vector can be controlled by the user with the mouse. See the section <a class="el" href="page_UserInteraction.html">User Interaction</a> for more details. If you pass three scalars, a vector with the corresponding components in <img class="formulaInl" alt="$x$" src="form_97.png"> , <img class="formulaInl" alt="$y$" src="form_100.png"> and <img class="formulaInl" alt="$z$" src="form_101.png"> -direction is created. If you only pass two scalars, the <img class="formulaInl" alt="$z$" src="form_101.png"> -component is set to zero. However, note that since <a class="el" href="group__grp__GAFunc.html#ga32">VecC2()</a> creates a vector in the space of 2D-conics, it accepts at most two parameters. Passing a multivector converts the <b>vector part</b> of this multivector to the appropriate space.<p>
<dl compact><dt><b>Attention:</b></dt><dd>For drawing multivectors, a right handed coordinate system is used, since this is what OpenGL uses. Therefore, the <img class="formulaInl" alt="$z$" src="form_101.png"> -axis points out of the computer screen and not into it. That is, if you want to move something away from the observer you have to move it in the negative <img class="formulaInl" alt="$z$" src="form_101.png"> -direction.</dd></dl>
For example, <code>A = VecE3(1,1,1)</code> assigns to <code>A</code> the multivector <img class="formulaInl" alt="$e_1 + e_2 + e_3$" src="form_106.png"> . A subsequent code-line like <code>PA = VecP3(A)</code> embeds <code>A</code> in projective space. That is, <code>PA</code> is assigned the multivector <img class="formulaInl" alt="$e_1 + e_2 + e_3 + e_4$" src="form_107.png"> .<p>
You can also create rotors with the functions <a class="el" href="group__grp__GAFunc.html#ga22">RotorE3()</a>, <a class="el" href="group__grp__GAFunc.html#ga26">RotorP3()</a>, <a class="el" href="group__grp__GAFunc.html#ga24">RotorN3()</a> and <a class="el" href="group__grp__GAFunc.html#ga21">RotorC2()</a>. For conformal space there also exist functions to create a sphere (<a class="el" href="group__grp__GAFunc.html#ga29">SphereN3()</a>), a translator (<a class="el" href="group__grp__GAFunc.html#ga31">TranslatorN3()</a>) and a dilator (<a class="el" href="group__grp__GAFunc.html#ga11">DilatorN3()</a>). For the conic space there is also a function that creates a reflection operator (<a class="el" href="group__grp__GAFunc.html#ga19">ReflectorC2()</a>). See the reference manual for more details.<p>
There are four functions to define variables for the basis elements of the different spaces: <a class="el" href="group__grp__GAFunc.html#ga7">DefVarsE3()</a>, <a class="el" href="group__grp__GAFunc.html#ga9">DefVarsP3()</a>, <a class="el" href="group__grp__GAFunc.html#ga8">DefVarsN3()</a> and <a class="el" href="group__grp__GAFunc.html#ga6">DefVarsC2()</a>. These functions take no parameters. The following tables show the variables defined by the three functions and their algebraic meaning. All these variables are of the type <code>multivector</code>.<p>
<table align="center" border="1" bgcolor="#EEEEEE" cellspacing="3" cellpadding="3">
<tr>
<td>Function  </td><td>Variable  </td><td>Content   </td></tr>
<tr>
<td><code><a class="el" href="group__grp__GAFunc.html#ga7">DefVarsE3()</a></code>  </td><td><code>id</code>  </td><td>1   </td></tr>
<tr>
<td></td><td><code>e1</code>  </td><td><img class="formulaInl" alt="$e_1$" src="form_10.png">   </td></tr>
<tr>
<td></td><td><code>e2</code>  </td><td><img class="formulaInl" alt="$e_2$" src="form_11.png">   </td></tr>
<tr>
<td></td><td><code>e3</code>  </td><td><img class="formulaInl" alt="$e_3$" src="form_12.png">   </td></tr>
<tr>
<td></td><td><code>I</code>  </td><td><img class="formulaInl" alt="$e_1\wedge e_2\wedge e_3$" src="form_13.png">   </td></tr>
</table>
<p>
The three basis vectors of Euclidean space <img class="formulaInl" alt="$\{ e_1, e_2, e_3 \}$" src="form_14.png"> all square to <img class="formulaInl" alt="$+1$" src="form_15.png"> . The variable <code>id</code> is defined in order to create grade zero multivectors in Euclidean space.<p>
<table align="center" border="1" bgcolor="#EEEEEE" cellspacing="3" cellpadding="3">
<tr>
<td>Function  </td><td>Variable  </td><td>Content  </td></tr>
<tr>
<td><code><a class="el" href="group__grp__GAFunc.html#ga9">DefVarsP3()</a></code>  </td><td><code>id</code>  </td><td>1  </td></tr>
<tr>
<td></td><td><code>e1</code>  </td><td><img class="formulaInl" alt="$e_1$" src="form_10.png">   </td></tr>
<tr>
<td></td><td><code>e2</code>  </td><td><img class="formulaInl" alt="$e_2$" src="form_11.png">   </td></tr>
<tr>
<td></td><td><code>e3</code>  </td><td><img class="formulaInl" alt="$e_3$" src="form_12.png">   </td></tr>
<tr>
<td></td><td><code>e4</code>  </td><td><img class="formulaInl" alt="$e_4$" src="form_30.png">   </td></tr>
<tr>
<td></td><td><code>I</code>  </td><td><img class="formulaInl" alt="$e_1\wedge e_2\wedge e_3\wedge e_4$" src="form_31.png">   </td></tr>
</table>
<p>
The four basis vectors of projective space <img class="formulaInl" alt="$\{ e_1, e_2, e_3, e_4 \}$" src="form_32.png"> all square to <img class="formulaInl" alt="$+1$" src="form_15.png"> . Note that this differs from some researchers which prefer to use a space-time basis for projective space, i.e. <img class="formulaInl" alt="$\{ e_1, e_2, e_3 \}$" src="form_14.png"> square to <img class="formulaInl" alt="$-1$" src="form_23.png"> and <img class="formulaInl" alt="$e_4$" src="form_30.png"> squares to <img class="formulaInl" alt="$+1$" src="form_15.png"> . The variable <code>id</code> is defined in order to create grade zero multivectors in projective space.<p>
<table align="center" border="1" bgcolor="#EEEEEE" cellspacing="3" cellpadding="3">
<tr>
<td>Function  </td><td>Variable  </td><td>Content  </td></tr>
<tr>
<td><code><a class="el" href="group__grp__GAFunc.html#ga8">DefVarsN3()</a></code>  </td><td><code>id</code>  </td><td>1  </td></tr>
<tr>
<td></td><td><code>e1</code>  </td><td><img class="formulaInl" alt="$e_1$" src="form_10.png">   </td></tr>
<tr>
<td></td><td><code>e2</code>  </td><td><img class="formulaInl" alt="$e_2$" src="form_11.png">   </td></tr>
<tr>
<td></td><td><code>e3</code>  </td><td><img class="formulaInl" alt="$e_3$" src="form_12.png">   </td></tr>
<tr>
<td></td><td><code>ep</code>  </td><td><img class="formulaInl" alt="$e_+$" src="form_16.png">   </td></tr>
<tr>
<td></td><td><code>em</code>  </td><td><img class="formulaInl" alt="$e_-$" src="form_17.png">   </td></tr>
<tr>
<td></td><td><code>e</code>  </td><td><img class="formulaInl" alt="$e_\infty$" src="form_113.png">   </td></tr>
<tr>
<td></td><td><code>einf</code>  </td><td><img class="formulaInl" alt="$e_\infty$" src="form_113.png">   </td></tr>
<tr>
<td></td><td><code>e0</code>  </td><td><img class="formulaInl" alt="$e_0$" src="form_19.png">   </td></tr>
<tr>
<td></td><td><code>n</code>  </td><td><img class="formulaInl" alt="$n$" src="form_20.png">   </td></tr>
<tr>
<td></td><td><code>nb</code>  </td><td><img class="formulaInl" alt="$\bar{n}$" src="form_179.png">   </td></tr>
<tr>
<td></td><td><code>I</code>  </td><td><img class="formulaInl" alt="$e_1\wedge e_2\wedge e_3\wedge e_+\wedge e_-$" src="form_21.png">   </td></tr>
</table>
<p>
In conformal space the four basis vectors <img class="formulaInl" alt="$\{ e_1, e_2, e_3, e_+ \}$" src="form_22.png"> square to <img class="formulaInl" alt="$+1$" src="form_15.png"> and <img class="formulaInl" alt="$e_-$" src="form_17.png"> squares to <img class="formulaInl" alt="$-1$" src="form_23.png"> . The composite elements <img class="formulaInl" alt="$e_\infty, e_0, n, \bar{n}$" src="form_180.png"> are defined as<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ e_\infty \equiv n := e_- + e_+\;;\quad e_0 \equiv \bar{n} := \frac{1}{2} (e_- - e_+) \]" src="form_181.png">
<p>
<p>
The pairs <img class="formulaInl" alt="$\{ e_\infty, e_0 \}$" src="form_182.png"> and <img class="formulaInl" alt="$\{ n, \bar{n} \}$" src="form_27.png"> are complementary null vectors. That is, <img class="formulaInl" alt="$e_\infty^2 = e_0^2 = n^2 = \bar{n}^2 = 0$" src="form_183.png"> and <img class="formulaInl" alt="$e_\infty\cdot e_0 = n\cdot \bar{n} = -1$" src="form_184.png"> . The two naming conventions for these null vector pairs are used by different researchers. Here both are defined so that nobody gets confused.<p>
<table align="center" border="1" bgcolor="#EEEEEE" cellspacing="3" cellpadding="3">
<tr>
<td>Function  </td><td>Variable  </td><td>Content  </td></tr>
<tr>
<td><code><a class="el" href="group__grp__GAFunc.html#ga6">DefVarsC2()</a></code>  </td><td><code>id</code>  </td><td>1  </td></tr>
<tr>
<td></td><td><code>e1</code>  </td><td><img class="formulaInl" alt="$e_1$" src="form_10.png">   </td></tr>
<tr>
<td></td><td><code>e2</code>  </td><td><img class="formulaInl" alt="$e_2$" src="form_11.png">   </td></tr>
<tr>
<td></td><td><code>e3</code>  </td><td><img class="formulaInl" alt="$e_3$" src="form_12.png">   </td></tr>
<tr>
<td></td><td><code>e4</code>  </td><td><img class="formulaInl" alt="$e_4$" src="form_30.png">   </td></tr>
<tr>
<td></td><td><code>e5</code>  </td><td><img class="formulaInl" alt="$e_5$" src="form_185.png">   </td></tr>
<tr>
<td></td><td><code>e6</code>  </td><td><img class="formulaInl" alt="$e_6$" src="form_186.png">   </td></tr>
<tr>
<td></td><td><code>I</code>  </td><td><img class="formulaInl" alt="$e_1\wedge e_2\wedge e_3\wedge e_4\wedge e_5\wedge e_6$" src="form_187.png">   </td></tr>
</table>
<p>
The six basis vectors of conic space <img class="formulaInl" alt="$\{ e_1, e_2, e_3, e_4, e_5, e_6 \}$" src="form_188.png"> all square to <img class="formulaInl" alt="$+1$" src="form_15.png"> . Vectors in this space basically encode symmetric 3 by 3 matrices. Details on the embedding can be found in the technical report <em>"Analysis of Local Image Structure using Intersections of Conics"</em> (<a href="http://www.perwass.de/published/perwass_tr0403_v1.pdf">download</a>). Given a symmetric 3 by 3 matrix it can be embedded in conic space by passing it through the function <a class="el" href="group__grp__GAFunc.html#ga32">VecC2()</a>. The opposite is also possible, by passing a vector in conic space to the function <a class="el" href="group__grp__Matrix.html#ga19">Matrix()</a>. Here is an example of that.<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__grp__VarEnv.html#ga0">_2dView</a> = 1;

    ?M = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>( [[1, 0, 0], [0, -1, 0], [0, 0, -1]] );
    ?C = <a class="code" href="group__grp__GAFunc.html#ga32">VecC2</a>(M);
    :<a class="code" href="group__grp__MVStyle__Global.html#ga0">IPNS</a>;
    :<a class="code" href="group__grp__ColVars.html#ga1">Red</a>;
    :C;

    :<a class="code" href="group__grp__MVStyle__Global.html#ga1">OPNS</a>;
    ?X = <a class="code" href="group__grp__GAFunc.html#ga32">VecC2</a>(1,0);
    :<a class="code" href="group__grp__ColVars.html#ga3">Blue</a>;
    :X;
    ?N = <a class="code" href="group__grp__Matrix.html#ga19">Matrix</a>(X);
</pre></div><p>
This script produces the output<p>
<div class="fragment"><pre class="fragment">    M = (| 1 0 0|, | 0 -1 0|, | 0 0 -1|)
    C = -0.707^e3 + 0.707^e4 + -0.707^e5
    X = 1^e1 + 0.707^e3 + 0.707^e4
    N = (| 1 0 1|, | 0 0 0|, | 1 0 1|)
</pre></div><p>
<hr>
 <h2><a class="anchor" name="sec_CalcMV">
Calculating with Multivectors</a></h2>
For all of the most important operations with multivectors an operator has been defined. The geometric product is the <code>*</code>, the inner product is the <code>.</code> and the outer product is the <code>^</code> operator. The prevalence of the operators also has been defined according to the usual standard. That is, <img class="formulaInl" alt="$A\cdot B\,C = (A\cdot B)\,C$" src="form_108.png"> , <img class="formulaInl" alt="$A\wedge B\, C = (A\wedge B)\,C$" src="form_109.png"> and <img class="formulaInl" alt="$A\cdot B\wedge C = A\cdot (B\wedge C)$" src="form_110.png"> .<p>
Division of multivectors is also defined through the operator &lt;tt&gt;/, whereby <img class="formulaInl" alt="$A / B = A B^{-1}$" src="form_103.png"> .<p>
<dl compact><dt><b>Attention:</b></dt><dd>The inner product of a scalar with any type of multivector or scalar is identically zero by definition.</dd></dl>
The other operators defined are the reverse <code> ~</code>, the inverse <code>!</code>, the <b>main involution</b> <code>'</code>, the dual <code>*</code>, the meet <code>&amp;</code>, the join <code>|</code> and the grade projection <code>°</code>. The inverse operator returns a zero multivector if the given multivector has no inverse.<p>
<dl compact><dt><b>Attention:</b></dt><dd><b>From version 1.4 onwards</b>, the grade projection operator of multivectors is no longer <code>#</code> but <code>°</code>. <b>From version 2.0 onwards</b>, the selection operator &lt;tt&gt;() can be used to extract single component elements from a multivector.</dd></dl>
The grade projection operator expects a multivector on the LHS and a counter on the RHS. For example, if <code>A</code> is a multivector variable then <code>A°2</code> is equivalent to <img class="formulaInl" alt="$< A >_2$" src="form_111.png"> . You can also select elements of a multivector with the selection operator &lt;tt&gt;(). For example,<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();

?A = 1 + 2*e1 + 3*I;

?A(1);
?A(2);
?A(8);

?A°1;
</pre></div><p>
produces the output <div class="fragment"><pre class="fragment">A = 1 + 2^e1 + 3^I
Constant = 1
Constant = 2
Constant = 3
Constant = 2^e1
</pre></div><p>
The main involution operator &lt;tt&gt;' only has an effect in conformal space, since there exists a basis vector with a negative signature. Here is an example that shows the effect.<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__grp__GAFunc.html#ga8">DefVarsN3</a>();
    
    ?em;
    ?'em;
    
    ?e1;
    ?'e1;
</pre></div><p>
This script has the output<p>
<div class="fragment"><pre class="fragment">em = 0.5^e + 1^e0
Constant = -0.5^e + -1^e0
e1 = 1^e1
Constant = 1^e1
</pre></div><p>
The join and meet operations only make sense when applied to blades. They will still give a result if their operands are no blades but that result is not useful. I gave the join and meet the symbols for bitwise OR (<code>|</code>) and bitwise AND (<code>&amp;</code>), as defined in C/C++, since this is what they do for blades. Note that the meet of a non-zero scalar with a blade returns 1. The join of a non-zero scalar with a blade returns the normalized blade. In fact, the join always returns a normalized blade.<p>
<a class="anchor" name="anchor_JoinMeetNullBlades"></a> From version 1.5 onwards, the meet and join operation now also work for null blades, which can turn up in conformal space. Note that the standard definition of join and meet do not include the case of null blades. I therefore extended the definition for this case, such that they are still useful operations. For example, in conformal space the intersection point of a line and a plane will be of the form <img class="formulaInl" alt="$X\wedge e_\infty$" src="form_112.png"> , where <img class="formulaInl" alt="$X$" src="form_79.png"> is the intersection point embedded in conformal space and <img class="formulaInl" alt="$e_\infty$" src="form_113.png"> is the point at infinity. Suppose we have a second point of this form <img class="formulaInl" alt="$Y\wedge e_\infty$" src="form_114.png"> . If we are now interested in the line passing through them we cannot simply calculate <img class="formulaInl" alt="$X\wedge e_\infty\wedge Y\wedge e_\infty$" src="form_115.png"> since this is zero. However, if the join operation could give us <img class="formulaInl" alt="$X\wedge Y\wedge e_\infty$" src="form_116.png"> , we would optain just the line we are looking for. And this is also how the extended join operation works. The extended meet work analogously, such that, for example, <img class="formulaInl" alt="$(e_1\wedge e_\infty)\vee (e_2\wedge e_\infty) = e_\infty. $" src="form_117.png"> Note that the function <a class="el" href="group__grp__GAFunc.html#ga14">FactorizeBlade()</a> also factorizes null blades properly from version 1.5 onwards. Here is an example script to demonstrate these properties. <div class="fragment"><pre class="fragment"><a class="code" href="group__grp__GAFunc.html#ga8">DefVarsN3</a>();

<span class="comment">// Define two null blades</span>
?A = <a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>(1,0,2) ^ e;
?B = <a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>(0,1,1) ^ e;

<span class="comment">// Their join</span>
?J = A | B;

<span class="comment">// Their meet</span>
?M = A &amp; B;
</pre></div> This script produces the following output. <div class="fragment"><pre class="fragment">A = 1^(e1^e) + 1^(e2^e) + -1^E
B = 1^(e2^e) + 1^(e3^e) + -1^E
J = 0.707^(e23^e) + -0.707^(e31^e) + 0.707^(e12^e) + -0.707^(e1^E) + 0.707^(e3^E)
M = 1.414^e
</pre></div><p>
<a class="anchor" name="anchor_AND_OR_Operator"></a> <dl compact><dt><b>Attention:</b></dt><dd>When the operators <code>&amp;</code> and <code>|</code> are applied to two counters, then a bitwise AND and OR operation is performed between the counters, respectively.</dd></dl>
Here is an example of the bitwise AND and OR operations. <div class="fragment"><pre class="fragment">? 1 &amp; 2;
? 3 &amp; 2;
? 1 | 2;
? 3 | 2;
</pre></div> which produces the following output <div class="fragment"><pre class="fragment">Constant = 0
Constant = 2
Constant = 3
Constant = 3
</pre></div><p>
You can take a multivector to the power of an integer value with the function <code>pow</code>. For example, <code>pow(e1^e2, 3)</code> returns the third power of <img class="formulaInl" alt="$e_1\wedge e_2$" src="form_118.png"> which is <img class="formulaInl" alt="$-e_1\wedge e_2$" src="form_119.png"> . However, <code>pow(e1^e2, 3.5)</code> returns a runtime error message.<p>
A function to evaluate the factorial of an integer value also exists (<code>fact</code>). It evaluates the factorial of integers between 0 and 170. Together with the <code>pow</code> function this enables you to evaluate Taylor expansions of multivector functions.<p>
By the way, to evaluate the Taylor series of the exponential function of a multivector up to degree twelve, you can use the function <code>exp</code>.<p>
<hr>
 <h2><a class="anchor" name="sec_VisMV">
Visualizing Multivectors</a></h2>
One of the most interesting features of CLUScript is that you can visualize multivectors very easily. Of course, not every multivector has a geometric interpretation, but blades and rotors can be represented geometrically. The geometric representation of blades can be given either as their outer or inner product null space. That is, a blade <img class="formulaInl" alt="$A_{<k>}$" src="form_120.png"> of grade <img class="formulaInl" alt="$k$" src="form_8.png"> represents the subspace of vectors <img class="formulaInl" alt="$X$" src="form_79.png"> which either satisfy <img class="formulaInl" alt="$A_{<k>}\wedge X = 0$" src="form_121.png"> or <img class="formulaInl" alt="$A_{<k>}\cdot X = 0$" src="form_122.png"> . Since <img class="formulaInl" alt="$(A_{<k>}\wedge X)^* = A_{<k>}\cdot X^*$" src="form_123.png"> the inner product null space (IPNS) is dual to the outer product null space (OPNS).<p>
Per default blades are represented through their OPNS in all spaces. You can also switch explicitly to the representation of blades through their IPNS using the function <code>SetMode</code>. From version 1.4 onwards you can switch between the OPNS and IPNS representation using the variables <code>OPNS</code> and <code>IPNS</code> respectively. For example, if you write <code>SetMode(IPNS)</code>, multivectors <b>in all spaces</b> are visualized by interpreting their inner product null space. Clearly, depending on the space they are in, blades represent different geometric entities.<p>
In general, planes and circles are sided geometric entities in Clifford algebra. That is, they have a front and a back. When you visualize a plane in a particular color, the front side of the plane appears in just that color, the back however, is drawn in a darker version of that color. Also the front side is more reflective than the back. This visualizes the sidedness of planes. For circles, the front side of a circle reflects light stronger than the back.<p>
Lines and planes are drawn centered on the point on the line or plane that is closest to the origin. This may not always be the most useful representation. At times you might want to change the offset vector of a line or plane. In order to do so you can use the function <code>Offset</code>. This function takes either two or three parameters. The first parameter is always the blade that you want to draw with a different offset vector and the second parameter is the new offset vector. The offset vector can be a vector defined in any space, as long as it represents a point in Euclidean space. The third, optional, parameter is the new scale of the line or plane. In the following example it is shown how to draw a line between two points in projective space. You can find this example under <code>LineP3.clu</code>. Also take a look at <code>StereoCamera.clu</code> for a more advanced example.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Define P3 Variables</span>
<a class="code" href="group__grp__GAFunc.html#ga9">DefVarsP3</a>();

<span class="comment">// Normalized homogeneous vectors</span>
:A = 2*e1 + e4:<a class="code" href="group__grp__ColVars.html#ga1">Red</a>;
:B = 3*e2 + e4:<a class="code" href="group__grp__ColVars.html#ga3">Blue</a>;
L = A^B;

<span class="comment">// Direction of line</span>
:V = L . e4:<a class="code" href="group__grp__ColVars.html#ga2">Green</a>;

<span class="comment">// Draw line starting at A with length sqrt(V.V)</span>
:<a class="code" href="group__grp__ColVars.html#ga5">Yellow</a>;
<a class="code" href="group__grp__DrawFunc.html#ga39">Offset</a>(L, A, <a class="code" href="group__grp__MathFunc.html#ga47">sqrt</a>(V.V));
</pre></div><p>
Rotors can also be visualized. They are always represented in the same way: a section of disc representing the rotation angle and a rotation axis. Rotations are always performed anti-clockwise with respect to the rotation axis. Note that the top-side of the disc section is visualized in a brighter color than the back-side. This gives you an additional visual cue to the orientation of the rotation plane. Furthermore, the disc is transparent, so as not to clutter the visualization too much.<p>
<dl compact><dt><b>Attention:</b></dt><dd>In conformal space you can only display rotors that either rotate about an axis through the origin (pure rotation), or general rotors of the type <img class="formulaInl" alt="$TR \tilde{T}$" src="form_124.png"> , where <img class="formulaInl" alt="$R$" src="form_125.png"> is a pure rotor and <img class="formulaInl" alt="$T$" src="form_126.png"> is a translator. Translators can also be visualized but not objects of the type <img class="formulaInl" alt="$TR$" src="form_127.png"> .</dd></dl>
Multivectors are visualized in CLUScript with the <code>:</code> operator. Simply write <code>:VecE3(1,2,3):Red</code> to draw the vector <img class="formulaInl" alt="$e_1 + 2e_2 + 3e_3$" src="form_128.png"> using the color red. (Recall that the colon operator is executed from right to left.) In the following I will list the special visualization features in the three spaces Euclidean, projective and conformal.<p>
<dl compact><dt><b>Attention:</b></dt><dd>The visualization engine is a state-machine. This means that if you apply a color to the state-machine via <code>:Red</code>, for example, then this color stays active until you switch to a different color. This is also true for the visualization modes that can be set with the function <code>SetMode</code>. They stay active until changed. Nevertheless, if a script is executed multiple times, standard variables like the current color or the drawing modes are reset to standard values before each execution. In this way you can always be sure of these states at the beginning of a script, even if states are changed within the script.</dd></dl>
The predefined colors currently available in CLUScript are controlled through the variables <code>Red</code>, <code>Green</code>, <code>Blue</code>, <code>Magenta</code>, <code>Cyan</code>, <code>Yellow</code>, <code>Orange</code>, <code>Black</code>, <code>White</code>. Each of these colors also has a medium bright and a dark version. These are named like the basic color prefixed by a <code>M</code> or <code>D</code>, respectively.<p>
Another global visualization switch is <a class="el" href="group__grp__MVStyle__Global.html#ga3">DRAW_POINT_AS_SPHERE</a>, which is independent of any space. After applying this switch using <a class="el" href="group__grp__DrawFunc.html#ga54">SetMode()</a> or the operator <code></code>: all points are drawn as small spheres. You can switch back to the default mode with <a class="el" href="group__grp__MVStyle__Global.html#ga2">DRAW_POINT_AS_DOT</a>.<h3><a class="anchor" name="subsec_VisE3">
Visualizing in Euclidean Space</a></h3>
In Euclidean space you can draw vectors, bivectors and the pseudoscalar. Scalars are not drawn.<p>
<ul>
<li>
<b>Vectors</b>. A vector is represented as a point at the position given by the vector and a line connecting the point with the origin. This is meant to visualize the double meaning of vectors in Euclidean space: on the one hand they may represent points, but on the other hand vectors are used to represent directions and hence the line. Note that the OPNS of a vector is a line through the origin. You can also change this visualization by using the following variables in the function <code>SetMode</code>: <ul>
<li>
<code>E3_DRAW_VEC_AS_LINE</code> This switches the visualization of vectors to the standard as described above.<p>
</li>
<li>
<code>E3_DRAW_VEC_AS_ARROW</code> This switches the visualization to arrows.<p>
</li>
<li>
<code>E3_DRAW_VEC_AS_POINT</code> This switches the visualization to points. </li>
</ul>
For example, if you want to draw the vector <img class="formulaInl" alt="$e1$" src="form_129.png"> as an arrow, write <div class="fragment"><pre class="fragment"><span class="comment">// Define the variables for E3</span>
<a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();

<span class="comment">// Set the mode.</span>
<span class="comment">// You could also simply write </span>
<span class="comment">//    :E3_DRAW_VEC_AS_ARROW;</span>
<span class="comment">//</span>
<a class="code" href="group__grp__DrawFunc.html#ga54">SetMode</a>(<a class="code" href="group__grp__MVStype__E3.html#ga2">E3_DRAW_VEC_AS_ARROW</a>);

<span class="comment">// Draw the vector</span>
:e1;
</pre></div><p>
</li>
<li>
<b>Bivectors</b> are represented by planes passing through the origin. As mentioned before the front side of a plane is drawn in a brighter color than the back. The area of the plane is equal to the magnitude of the bivector. You can also influence how planes are visualized by using the following two variables. <ul>
<li>
<code>E3_DRAW_PLANE_AS_RECT</code> This switches the visualization of planes to rectangles.<p>
</li>
<li>
<code>E3_DRAW_PLANE_AS_DISK</code> This switches the visualization of planes to discs. </li>
</ul>
<p>
</li>
<li>
<b>Trivectors</b> are proportional to the pseudoscalar in Euclidean space. Hence a trivector is represented as a cube centered on the origin. This is meant to represent that the OPNS of a trivector is the whole space. The volume of the cube is equal to the magnitude of the trivector. </li>
</ul>
<h3><a class="anchor" name="subsec_VisP3">
Visualizing in Projective space</a></h3>
In projective space you can draw vectors, bivectors, trivectors and four-vectors. Scalars are not drawn.<p>
<ul>
<li>
<b>Vectors</b>. A vector is represented as a point at the position given by the vector. If the vector has no <img class="formulaInl" alt="$e_4$" src="form_30.png"> component it is also called a direction vector and is represented as an arrow pointing in the appropriate direction from the origin.<p>
</li>
<li>
<b>Bivectors</b> are represented by lines. Lines are always centered on the point on the line which lies closest to the origin. The length of a line is equal to the magnitude of the bivector. If the bivector represents a line at infinity then it is represented as a rhombus centered on the origin.<p>
</li>
<li>
<b>Trivectors</b> are represented by planes. Planes are always centered on the point on the plane that lies closest to the origin. The area of the plane is equal to the magnitude of the trivector. If the trivector represents a plane at infinity then it is represented by a tetrahedron centered on the origin.<p>
</li>
<li>
<b>Quadvectors</b> are proportional to the pseudoscalar. As in Euclidean space they are represented by a cube centered on the origin. The volume of the cube is equal to the magnitude of the quadvector. </li>
</ul>
<h3><a class="anchor" name="subsec_VisN3">
Visualizing in Conformal space</a></h3>
In conformal space you can draw vectors, bivectors, trivectors, quadvectors and quintvectors. Scalars are not drawn. You can either draw the IPNS (default) or OPNS of blades. To switch between these modes call the function <code>SetMode</code> with the parameters <code>N3_IPNS</code> and <code>N3_OPNS</code>, respectively. For example, <code>SetMode(N3_IPNS)</code> switches to IPNS mode. Furthermore, spheres can either be drawn as wire-frames (default) or as solid spheres. To switch between these modes use <code>N3_WIRE</code> and <code>N3_SOLID</code>, respectively. Note that you can set any number of modes in a single call to <code>SetMode</code>. For example, <code>SetMode(N3_IPNS, N3_SOLID)</code> sets both modes. From CLUScript version 1.3 onwards also imaginary objects are visualized. That is, points pairs, circles and spheres with imaginary radius are drawn in a special form, as detailed below. By default imaginary objects are drawn. You can switch this off with the variable <code>N3_HIDE_IMAG</code>. In order to show imaginary objects again use the switch <code>N3_SHOW_IMAG</code>.<p>
Unless stated otherwise, the following discussion of blades refers to their OPNS.<p>
<ul>
<li>
<b>Vectors</b>. A vector is represented as a point at the appropriate position if it is a null vector. A null vector is a vector of the form <img class="formulaInl" alt="$X = \mathbf{x} + \frac{1}{2}\mathbf{x}^2 e + e_0$" src="form_130.png"> , where <img class="formulaInl" alt="$\mathbf{x}$" src="form_131.png"> is the corresponding vector in . The function <code>VecN3</code> creates vectors of this type. The IPNS of a vector can also represent a sphere. In that case the vector has the form <img class="formulaInl" alt="$S = X - \frac{1}{2}\rho^2 e$" src="form_132.png"> , where <img class="formulaInl" alt="$\rho$" src="form_4.png"> is the radius of the sphere. In this respect the IPNS of a vector of the form <img class="formulaInl" alt="$S = X + \frac{1}{2}\rho^2 e$" src="form_133.png"> refers to a sphere with radius <img class="formulaInl" alt="$\sqrt{-1}\,\rho$" src="form_134.png"> , i.e. a sphere with an imaginary radius. Such spheres are visualized as transparent objects when the visualization mode <code>N3_SHOW_IMAG</code> is set (default).<p>
A vector of the form <img class="formulaInl" alt="$X = \mathbf{x}$" src="form_135.png"> projects to infinity in Euclidean space since it has no <img class="formulaInl" alt="$e_0$" src="form_19.png"> component. Nevertheless, the IPNS of such a vector is a plane that goes through the origin. Its OPNS on the other hand is <img class="formulaInl" alt="$\alpha \mathbf{x}$" src="form_136.png"> where <img class="formulaInl" alt="$\alpha$" src="form_137.png"> is some scalar. That is, it does not actually have an OPNS we could visualize. Despite this, such a vector may be interpreted as a point at infinity or direction vector as in projective space. It is therefore visualized as an arrow.<p>
</li>
<li>
<b>Bivectors</b> represent point pairs if created by two null vectors. For example, if <img class="formulaInl" alt="$X, Y$" src="form_138.png"> are two null vectors as defined above, then <img class="formulaInl" alt="$X\wedge Y$" src="form_139.png"> represents the point pair <img class="formulaInl" alt="$(X, Y)$" src="form_140.png"> . Accordingly, such a bivector is visualized as the corresponding point pair. A point pair can also be regarded as a one-dimensional sphere and may also have an imaginary radius in this respect. Such imaginary point pairs are visualized as two points with a dotted line in between. A bivector of the form <img class="formulaInl" alt="$X\wedge n$" src="form_141.png"> may then also be interpreted as the point pair <img class="formulaInl" alt="$(X, n)$" src="form_142.png"> , whereby <img class="formulaInl" alt="$n$" src="form_20.png"> represents the point at infinity. Such bivectors are also called the {affine representation} of points. Therefore, they are visualized just as the single point <img class="formulaInl" alt="$X$" src="form_79.png"> .<p>
</li>
<li>
<b>Trivectors</b> either represent lines or circles. If <img class="formulaInl" alt="$X,Y,Z$" src="form_143.png"> are null vectors then a trivector of the type <img class="formulaInl" alt="$X\wedge Y\wedge Z$" src="form_144.png"> represents a circle through points <img class="formulaInl" alt="$X$" src="form_79.png"> , <img class="formulaInl" alt="$Y$" src="form_88.png"> and <img class="formulaInl" alt="$Z$" src="form_145.png"> . Such a trivector may also represent a circle with imaginary radius, in which case it is visualized as a dotted circle. A trivector of the type <img class="formulaInl" alt="$X\wedge Y\wedge n$" src="form_146.png"> accordingly represents a circle through the points <img class="formulaInl" alt="$X$" src="form_79.png"> , <img class="formulaInl" alt="$Y$" src="form_88.png"> and <img class="formulaInl" alt="$n$" src="form_20.png"> , the point at infinity. Such a circle of infinite radius is equivalent to a line through <img class="formulaInl" alt="$X$" src="form_79.png"> and <img class="formulaInl" alt="$Y$" src="form_88.png"> and will be visualized as such.<p>
</li>
<li>
<b>Quadvectors</b> either represent planes or spheres. If <img class="formulaInl" alt="$X, Y, Z, W$" src="form_147.png"> are null vectors then a quadvector of the type <img class="formulaInl" alt="$X\wedge Y\wedge Z\wedge n$" src="form_148.png"> represents a sphere through points <img class="formulaInl" alt="$X$" src="form_79.png"> , <img class="formulaInl" alt="$Y$" src="form_88.png"> , <img class="formulaInl" alt="$Z$" src="form_145.png"> , <img class="formulaInl" alt="$n$" src="form_20.png"> , i.e. a sphere of infinite radius which is visualized as the plane through <img class="formulaInl" alt="$X$" src="form_79.png"> , <img class="formulaInl" alt="$Y$" src="form_88.png"> and <img class="formulaInl" alt="$Z$" src="form_145.png"> . A quadvector of the type <img class="formulaInl" alt="$X\wedge Y\wedge Z\wedge W$" src="form_149.png"> represents a sphere if and only if the four vectors are not co-planar. Such a quadvector may also represent a sphere with imaginary radius, in which case it is visualized as a transparent sphere. Furthermore, in conformal space the outer product of four null vectors that represent four co-planar points in Euclidean space is not null! Instead it represents the plane through the four points. Take a look at the script <code>Sphere.clu</code> to play around with these effects.<p>
</li>
<li>
<b>Quintvectors</b> are proportional to the pseudoscalar. They are represented as cubes centered on the origin. </li>
</ul>
<p>
Note that Euclidean space and projective space can be regarded as being embedded in conformal space. In general one can say that if you take an algebraic object in conformal space that represents a geometric entity and wedge it with <img class="formulaInl" alt="$n$" src="form_20.png"> (the point at infinity) you get an object in projective space in which the conformal space object is embedded. For example, take a point pair <img class="formulaInl" alt="$X\wedge Y$" src="form_139.png"> in . <img class="formulaInl" alt="$X\wedge Y\wedge n$" src="form_146.png"> gives the line that goes through both points. Also, if <img class="formulaInl" alt="$X\wedge Y\wedge Z$" src="form_144.png"> represents a circle in conformal space, then <img class="formulaInl" alt="$X\wedge Y\wedge Z\wedge e$" src="form_150.png"> represents the plane in which the circle lies. If such algebraic entities are then also wedged with <img class="formulaInl" alt="$e_0$" src="form_19.png"> (the origin), then we go to Euclidean space. For example, given the point <img class="formulaInl" alt="$X = \mathbf{x} + \frac{1}{2}\mathbf{x}^2 e + e_0$" src="form_130.png"> , then <img class="formulaInl" alt="$X\wedge e\wedge e_0$" src="form_151.png"> represents the line through the origin in the direction of <img class="formulaInl" alt="$\mathbf{x}$" src="form_131.png"> . This is exactly what we would obtain when visualizing <img class="formulaInl" alt="$\mathbf{x}$" src="form_131.png"> in Euclidean space. Similarly, <img class="formulaInl" alt="$X\wedge Y\wedge e\wedge e_0$" src="form_152.png"> is a plane through the origin and <img class="formulaInl" alt="$X\wedge Y\wedge Z\wedge e\wedge e_0$" src="form_153.png"> is the whole space.<p>
Also note that, for example, the OPNS of <img class="formulaInl" alt="$e1\wedge e$" src="form_154.png"> is visualized as an arrow, which is to represent a point at infinity. The OPNS of <img class="formulaInl" alt="$e1\wedge e2\wedge e$" src="form_155.png"> is a line at infinity. This is visualized as a doted circle with two arrows. The OPNS of <img class="formulaInl" alt="$e1\wedge e2\wedge e3\wedge e$" src="form_156.png"> is a plane at infinity which is visualized as a rhombus with arrows. The same can be obtained by visualizing the IPNS of <img class="formulaInl" alt="$e1\wedge e2\wedge e$" src="form_155.png"> , <img class="formulaInl" alt="$e1\wedge e$" src="form_154.png"> and <img class="formulaInl" alt="$e$" src="form_18.png"> , respectively. Furthermore, the intersection of a plane with a circle lying in a parallel plane gives an imaginary point pair at infinity. Here is an example script, which creates such an object.<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__grp__GAFunc.html#ga8">DefVarsN3</a>();
    
    <span class="comment">// The Plane</span>
    :<a class="code" href="group__grp__ColVars.html#ga1">Red</a>;
    :P = <a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>(0,0,0)^<a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>(1,0,0)^<a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>(0,0,1)^e;
    
    <span class="comment">// The Circle</span>
    :<a class="code" href="group__grp__ColVars.html#ga3">Blue</a>;
    :C = <a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>(0,1,0)^<a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>(1,1,0)^<a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>(0,1,1);
    
    <span class="comment">// Their intersection</span>
    :<a class="code" href="group__grp__ColVars.html#ga2">Green</a>;
    :X = P &amp; C;
</pre></div><p>
The visulization looks like this.<p>
<div align="center">
<img src="MVVisEx1.jpg" alt="MVVisEx1.jpg">
</div>
<h3><a class="anchor" name="subsec_VisC2">
Visualizing in Conic Space</a></h3>
The 6D-conic space implemented, basically embeds symmetric 3 by 3 matrices. The Clifford algebra over this vector space allows for the construction of conics through the outer product of five points. The result is the 2d-conic that passes through the five points, which is unique. So far, conics and the intersection of two conics can be visualized. For example,<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__grp__VarEnv.html#ga0">_2dView</a> = 1;
:<a class="code" href="group__grp__MVStyle__Global.html#ga3">DRAW_POINT_AS_SPHERE</a>;

A = <a class="code" href="group__grp__GAFunc.html#ga32">VecC2</a>(1,0);
B = <a class="code" href="group__grp__GAFunc.html#ga32">VecC2</a>(-1,0);
C = <a class="code" href="group__grp__GAFunc.html#ga32">VecC2</a>(0,1);
D = <a class="code" href="group__grp__GAFunc.html#ga32">VecC2</a>(0,-1);

:<a class="code" href="group__grp__ColVars.html#ga1">Red</a>;
:E = <a class="code" href="group__grp__GAFunc.html#ga32">VecC2</a>(1);  <span class="comment">// user interaction</span>

:<a class="code" href="group__grp__ColVars.html#ga8">White</a>;
:conic = A^B^C^D^E; <span class="comment">// Conic through A,B,C,D,E</span>

:<a class="code" href="group__grp__ColVars.html#ga7">Orange</a>;
:conic2 = A^B^C^D^<a class="code" href="group__grp__GAFunc.html#ga32">VecC2</a>(1,1);

<span class="comment">// Intersection of both conics</span>
:<a class="code" href="group__grp__ColVars.html#ga2">Green</a>;
:conic &amp; conic2;    <span class="comment">// The standard meet operation</span>
</pre></div><p>
produces the following visualization after moving the point <code>E</code> with the mouse a bit.<p>
<div align="center">
<img src="MVVisConicEx1.jpg" alt="MVVisConicEx1.jpg">
</div>
<p>
<hr>
 <h2><a class="anchor" name="sec_Plot">
Plotting Vector Functions</a></h2>
The funtion <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a> allows you to create 1D and 2D-parametric plots. For example, to draw the function <img class="formulaInl" alt="$f(x) = x^2$" src="form_157.png"> in the range <img class="formulaInl" alt="$[-2,2]$" src="form_158.png"> with 40 steps you need to write <code>:Plot( x*e1 + x*x*e2, [x, -2, 2, 40])</code>. The first parameter of <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a> gives the function that is to be plotted. This function needs to return something that represents a point Euclidean 3D-space. For example, you can draw the function <img class="formulaInl" alt="$sin(x)/x$" src="form_159.png"> also as follows.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__grp__GAFunc.html#ga9">DefVarsP3</a>();
:<a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>(0.1*x*x*e1 + <a class="code" href="group__grp__MathFunc.html#ga44">sin</a>(x)*e2 + x*e4, [x, -4*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>, 4*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>, 61]);
</pre></div><p>
Although the vector returned by the function lies in projective space, it is projected into Euclidean space before being plotted. Note that the function would not be evaluated correctly at the position <img class="formulaInl" alt="$x = 0$" src="form_160.png"> . By choosing 61 steps to draw the function we simply jump over this (undefined) point.<p>
The return value of <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a> is of type <code>vertexlist</code>. A vertex list simply contains a number of vertices, i.e. 3D-points, that are connected in some way when drawn. A vertex list can be drawn with the colon operator. Therefore, we can also write:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();
SINC_P2 = <a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>(0.1*x*x*e1 + <a class="code" href="group__grp__MathFunc.html#ga44">sin</a>(x)*e2 + x*e3, [x, -4*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>, 4*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>, 61]);
SINC_E2 = <a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>(0.1*x*e1 + <a class="code" href="group__grp__MathFunc.html#ga44">sin</a>(x)/x*e2, [x, -4*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>, 4*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>, 61]);

<span class="comment">// Print the vertices</span>
?SINC_P2;
?SINC_E2;

<span class="comment">// Now plot both functions</span>
:SINC_P2:<a class="code" href="group__grp__ColVars.html#ga1">Red</a>;
:SINC_E2:<a class="code" href="group__grp__ColVars.html#ga3">Blue</a>;
</pre></div><p>
The two plots are first saved in VertexList variables, then their values are printed and in the end they are drawn. The visualization looks like this:<p>
<div align="center">
<img src="PlotEx4.jpg" alt="PlotEx4.jpg">
</div>
<p>
The <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a> function simply executes the commands passed as first parameter for every value of the free parameter. This does not mean that you have to use the free parameter in the function. Therefore, we can for example draw coupled twists in the following way.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__grp__GAFunc.html#ga7">DefVarsE3</a>();
A = e1;
B = e1;

R = <a class="code" href="group__grp__GAFunc.html#ga22">RotorE3</a>(0, 0, 1, 10*<a class="code" href="group__grp__MathConst.html#ga2">RadPerDeg</a>);
R2 = <a class="code" href="group__grp__GAFunc.html#ga22">RotorE3</a>(0, 0, 1, -5*<a class="code" href="group__grp__MathConst.html#ga2">RadPerDeg</a>);

:<a class="code" href="group__grp__ColVars.html#ga2">Green</a>;
:<a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>((A = R*A*~R) + (B = R2*B*~R2), [x, 0, 1, 72]);
</pre></div><p>
This produces the visualization:<p>
<div align="center">
<img src="MVVisPlotEx1.jpg" alt="MVVisPlotEx1.jpg">
</div>
<p>
Here the function <code>(A = R*A* ~R) + (B = R2*B* ~R2)</code> is simply executed 73 times. Note that since the given range is split into 72 parts, the function is evaluated at 73 points. Since <code>A</code> and <code>B</code> are at every step replaced with a rotated version of themselves, the resultant plot is that of a coupled twist. <b>Take a look</b> at the script <code>Plot1.clu</code> for a more advanced example.<p>
Just as you can draw point-valued 1D-functions, it is also possible to draw circle- and line-valued 1D-functions, as well as point-valued 2D-functions, i.e. surfaces. Circle-valued functions are functions that return 3-blades in conformal space which represent circles in Euclidean space. Similarly, line-valued functions are functions that return 2-blades in projective space or 3-blades in conformal space, which represent lines. In both cases, <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a> draws the surface spanned by the circles or lines. Here is a simple example of a circle valued function.<p>
<div class="fragment"><pre class="fragment">    f1 = { x = _P(1); <a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>(x,0.1,0) }
    f2 = { x = _P(1); <a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>(0,-0.1,x) }
    f3 = { x = _P(1); <a class="code" href="group__grp__GAFunc.html#ga39">VecN3</a>(-0.1,x,0) }

    :<a class="code" href="group__grp__ColVars.html#ga1">Red</a>;
    :<a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>(f1(x), [x,-1,1,20]);

    :<a class="code" href="group__grp__ColVars.html#ga2">Green</a>;
    :<a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>(f2(x), [x,-1,1,20]);

    :<a class="code" href="group__grp__ColVars.html#ga3">Blue</a>;
    :<a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>(f3(x), [x,-1,1,20]);

    :<a class="code" href="group__grp__ColVars.html#ga8">White</a>;
    :<a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>(f1(x)^f2(x)^f3(x), [x, -1, 1, 20]);
</pre></div><p>
This produces the following visualization<p>
<div align="center">
<img src="PlotCircSurf1.jpg" alt="PlotCircSurf1.jpg">
</div>
<p>
Such circle surfaces are actually easier to view, if the color changes along the surface. This can be achieved by adding a color function. The last line of the previous example then looks like this.<p>
<div class="fragment"><pre class="fragment">    :<a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>([ f1(x)^f2(x)^f3(x),              <span class="comment">// The function</span>
            <a class="code" href="group__grp__DrawFunc.html#ga2">Color</a>(x*x, 0.8*<a class="code" href="group__grp__RanFunc.html#ga1">Ran</a>(), 1-x*x)],  <span class="comment">// The colors</span>
          [x, -1, 1, 20]);
</pre></div><p>
This results in the following.<p>
<div align="center">
<img src="PlotCircSurf2.jpg" alt="PlotCircSurf2.jpg">
</div>
<p>
If you want to plot a 2D-function, you can also use the <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a> function. Here is an example.<p>
<div class="fragment"><pre class="fragment">    :<a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>(<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(y, 0.3*<a class="code" href="group__grp__MathFunc.html#ga16">cos</a>(2*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>*x*y), x), 
            [x, -1, 1, 20],
            [y, -1, 1, 20]);
</pre></div><p>
The surface looks like this.<p>
<div align="center">
<img src="Plot2DSurf1.jpg" alt="Plot2DSurf1.jpg">
</div>
<p>
You can now also add a color function and also a normal function. Both are optional and their order is also arbitrary. However, the first function has to be the function to be plotted. If no normal function is given, the normals are evaluated numerically. Here is an example with a color and normal function.<p>
<div class="fragment"><pre class="fragment">    :<a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>( [ <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(y, 0.3*<a class="code" href="group__grp__MathFunc.html#ga16">cos</a>(2*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>*x*y), x),        <span class="comment">// The function</span>
             <a class="code" href="group__grp__DrawFunc.html#ga2">Color</a>(x*x, x*x*y*y, y*y),              <span class="comment">// The color</span>
             *( <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(0,-0.6*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>*y*<a class="code" href="group__grp__MathFunc.html#ga44">sin</a>(2*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>*x*y),1)  <span class="comment">// The normal</span>
               ^<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(1,-0.6*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>*x*<a class="code" href="group__grp__MathFunc.html#ga44">sin</a>(2*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>*x*y),0))
            ],
            [x, -1, 1, 20],
            [y, -1, 1, 20]);
</pre></div><p>
This generates the following visualization.<p>
<div align="center">
<img src="Plot2DSurf2.jpg" alt="Plot2DSurf2.jpg">
</div>
<p>
It can also be interesting to draw the normals on top of the surface. This is achieved by adding a fourth parameter to <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a>, which gives the size of the normals. Note that you need not give a normal function in order to draw the normals. When normals are drawn, <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a> returns a list of two vertex lists. The first element of this list is the vertex list for the surface and the second one is the vertex list for the normals. Have a look at the example script '<code>PlotTest4.clu</code>' for an example of how this can be used advantageously. Here is the example from above, now with normals drawn.<p>
<div class="fragment"><pre class="fragment">    :<a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>( [ <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(y, 0.3*<a class="code" href="group__grp__MathFunc.html#ga16">cos</a>(2*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>*x*y), x),        <span class="comment">// The function</span>
             <a class="code" href="group__grp__DrawFunc.html#ga2">Color</a>(x*x, x*x*y*y, y*y),              <span class="comment">// The color</span>
             *( <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(0,-0.6*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>*y*<a class="code" href="group__grp__MathFunc.html#ga44">sin</a>(2*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>*x*y),1)  <span class="comment">// The normal</span>
               ^<a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(1,-0.6*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>*x*<a class="code" href="group__grp__MathFunc.html#ga44">sin</a>(2*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>*x*y),0))
            ],
            [x, -1, 1, 20],
            [y, -1, 1, 20],
            0.1);
</pre></div><p>
This generates the following visualization.<p>
<div align="center">
<img src="Plot2DSurf3.jpg" alt="Plot2DSurf3.jpg">
</div>
<p>
Here is yet another example with a more interesting surface.<p>
<div class="fragment"><pre class="fragment">    :<a class="code" href="group__grp__DrawFunc.html#ga40">Plot</a>( [ <a class="code" href="group__grp__GAFunc.html#ga36">VecE3</a>(0.3*<a class="code" href="group__grp__MathFunc.html#ga16">cos</a>(2*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>*y), 0.3*<a class="code" href="group__grp__MathFunc.html#ga16">cos</a>(2*<a class="code" href="group__grp__MathConst.html#ga1">Pi</a>*x), x*y),      <span class="comment">// The function</span>
             <a class="code" href="group__grp__DrawFunc.html#ga2">Color</a>(x*x,y*y,x*x*y*y)                             <span class="comment">// The color</span>
            ],
            [x, -1, 1, 20],
            [y, -1, 1, 20]);
</pre></div><p>
It looks like this.<p>
<div align="center">
<img src="Plot2DSurf4.jpg" alt="Plot2DSurf4.jpg">
</div>
<p>
Also have a look at the functions <a class="el" href="group__grp__DrawFunc.html#ga14">DrawLineSurface()</a>, <a class="el" href="group__grp__DrawFunc.html#ga10">DrawCircleSurface()</a>, <a class="el" href="group__grp__DrawFunc.html#ga26">DrawPointSurface()</a> and <a class="el" href="group__grp__DrawFunc.html#ga24">DrawPointGrid()</a>. In fact, the function <a class="el" href="group__grp__DrawFunc.html#ga40">Plot()</a> uses these to do the advanced plotting. </body></html>
